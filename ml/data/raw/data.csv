pr_number,html_url,state,is_draft,merged,title,body,author_association,author_account_age_days,additions,deletions,changed_files,commits_count,body_len,created_day_of_week,created_hour,hours_to_merge,review_comments_count,issue_comments_count,requested_reviewers_count,labels,milestone,head_branch,base_branch,file_extensions
5829,https://github.com/pallets/flask/pull/5829,closed,False,True,Docs typo/markup fixes,Just two typos I've run into.,CONTRIBUTOR,6143,5,5,2,2,29,1,7,12.72,0,0,0,,,patch-1,main,rst
5818,https://github.com/pallets/flask/pull/5818,closed,False,True,pass context through dispatch methods,"The current `AppContext` object is passed through the various request dispatch methods, rather than each method accessing the proxies. closes #5815 

@pgjones first proposed this in #5229 as a way to speed up dispatch especially for Quart and async views. This PR applies to more methods, and also implements compatibility during a deprecation period.

Dispatch methods now take `ctx: AppContext` as the first parameter. The following `Flask` methods were changed:

- `update_template_context`
- `handle_http_exception`
- `handle_user_exception`
- `handle_exception`
- `log_exception`
- `dispatch_request`
- `full_dispatch_request`
- `finalize_request`
- `make_default_options_response`
- `preprocess_request`
- `process_response`
- `do_teardown_request`
- `do_teardown_appcontext`

`url_for` and `make_response` were not changed, as it's much more likely that these are called from user code that only has access to the proxy.

An `__init_subclass__` class method is added to detect old signatures on subclasses of `Flask`. The second parameter is inspected (first is self). If it is not annotated, it must be named `ctx`. If it is annotated, it must either be the string or class `AppContext`. If an old signature is detected, the method is wrapped to remove the argument when other `Flask` methods call it during dispatch. The base method is also wrapped to inject the argument so that `super().base_method` from the overridden method will continue to work.

I did not apply the compat wrapper to every base `Flask` method, only the ones that a subclass overrides. Therefore, if user code is directly calling these internal dispatch methods, they will get a `TypeError`. This is only likely (and unlikely at that) to happen during testing. I did this over concern that the wrapper would be unnecessary and a performance hit for most applications. If we get bug reports we can consider adding the wrapper.",MEMBER,5037,167,72,6,1,1931,5,0,1408.04,0,0,0,,3.2.0,pass-context,main,"py, rst"
5812,https://github.com/pallets/flask/pull/5812,closed,False,True,merge app and request context,"Merges the `RequestContext` class into the `AppContext` class. closes #5639

A lot of the size of this PR is rewriting or cleaning up docs related to the contexts. See `ctx.py` for the bulk of the work, and even there it's pretty much no new code, mostly deduplication. The ""request context"" still exists, but what data is available on the context object is what distinguishes it from an ""app context"" now.

How the user works with the context is pretty much unchanged. For example, `teardown_request` and `teardown_appcontext` still both exist, `app.app_context` and `app.test_request_context`, etc. All the same global proxies, `current_app`, `g`, `request`, and `session` still exist and are still available. in the same situations they were before.

The difference is that we no longer have to track whether an app context is already pushed when pushing a request context. This was already sort of an artificial behavior, it was not something that would ever happen under intended/documented request or testing scenarios. Now, every request always sets the app, and the request if request data is given. This greatly simplifies the internal data, as we simply need to record the previous value of the context var to restore on pop.

Some code in app internals was changed to use the contextvar directly, which code was already doing. This probably gains some tiny bit of performance rather than going through the proxies. When we go ahead with #5229 and beyond, we'll be passing around the context objects directly and won't even need to use the contextvar.

---

There are a few implications for testing that may have used `with app.app_context()` around a test client request. I've already highly discouraged this practice in issues over the years because it was already causing other issues. None of these patterns were in our docs.

With the old behavior, an app context was not pushed if one was already pushed when pushing a request context. Therefore,  `teardown_app` functions would only run once the `with` block exited rather than when the request exited. Along with using `with client` around everything, this was already the source of occasional bug reports and questions. The docs also say that no assumptions should be made about how many times a teardown function will be called or what data will be set for them.

Also, `g` was part of the app context, not the request context. Data could be set on `g` ahead of the request, because a new app context wouldn't be pushed. This was never documented, I don't know where I saw it.

```python
# do not do this, for example only
with app.app_context():
    g.user = test_user
    r = client.get(""/secret"")
```

It's not in Flask's docs or tests. The docs show making a request to login before making the request being tested, relying on the session to persist across requests. If you _really_ wanted to set up `g` beforehand, the signal docs show using the `appcontext_pushed` signal to modify the current context's `g` once it's created.

A project may run into some failed tests when upgrading, if they were relying on this. However, the failure would indicate patterns that were already unsound and should be fixed, so I don't see this as a blocker.

Interestingly, `copy_current_request_context` was already not copying `g`. I thought about changing this, but concluded that it was a good thing, because `g` is often used to store connections/caches that are not concurrent safe, such as Flask-SQLAlchemy's `db.session`.",MEMBER,5030,779,1007,36,1,3517,4,22,169.01,0,3,0,,3.2.0,merge-contexts,main,"py, rst"
5800,https://github.com/pallets/flask/pull/5800,closed,False,True,release version 3.1.2,,MEMBER,5005,5,5,3,1,0,1,20,0.35,0,0,0,,3.1.2,release-3.1.2,stable,"lock, rst, toml"
5799,https://github.com/pallets/flask/pull/5799,closed,False,True,refactor stream_with_context for async views,"Store the app context as well as the request context when creating the generator. This prevents the request context from automatically creating and pushing a different app context. Then push the app context first, and push them only when iteration starts, not during setup. This prevents the request context from automatically popping the app context, and avoids associating the internal ContextVar with the temporary event loop in async views.

fixes #5774",MEMBER,5005,63,32,3,1,459,1,15,0.02,0,0,0,async,3.1.2,stream-context,stable,"py, rst"
